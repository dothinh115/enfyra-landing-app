name: Deploy to VPS
on:
  push:
    branches: [main]
  workflow_dispatch:
  schedule:
    - cron: "0 * * * *"

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Install sshpass
        run: |
          sudo apt-get update -y
          sudo apt-get install -y sshpass

      - name: Deploy to VPS via sshpass
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_PASSWORD: ${{ secrets.VPS_PASSWORD }}
        run: |
          EVENT_NAME="${{ github.event_name }}"
          sshpass -p "$VPS_PASSWORD" ssh -o StrictHostKeyChecking=no $VPS_USER@$VPS_HOST "bash -s \"$EVENT_NAME\"" <<'ENDSSH'
            # Set project variables
            export PROJECT_NAME="landing-app"
            export APP_DIR="/apps/landing-app"
            export EVENT_NAME="$1"

            # Setup PATH for tools
            export PATH="$PATH:/usr/bin:/usr/local/bin:$HOME/.local/bin"

            # Find tool paths
            GIT_PATH=$(which git || echo "/usr/bin/git")
            NPM_PATH=$(which npm || echo "/usr/bin/npm")
            YARN_PATH=$(which yarn || echo "")
            PM2_PATH=$(which pm2 || echo "$HOME/.local/bin/pm2")

            # Install yarn if not found
            if [ -z "$YARN_PATH" ]; then
              echo "Yarn not found, installing..."
              $NPM_PATH install -g yarn
              YARN_PATH=$(which yarn || echo "$HOME/.local/bin/yarn")
            fi

            echo "=== Starting PM2 Deployment ==="
            echo "Tools found:"
            echo "Git: $GIT_PATH"
            echo "NPM: $NPM_PATH"
            echo "Yarn: $YARN_PATH"
            echo "PM2: $PM2_PATH"

            # Navigate to app directory
            cd $APP_DIR
            echo "Current directory: $(pwd)"

            # Check for new code (only for scheduled runs)
            if [ "$EVENT_NAME" = "schedule" ]; then
              echo "=== Checking for new code (scheduled run) ==="
              
              # Ensure we're on the right branch
              $GIT_PATH checkout main 2>/dev/null || true
              
              # Get current commit BEFORE fetching
              CURRENT_COMMIT=$($GIT_PATH rev-parse HEAD 2>/dev/null || echo "none")
              echo "Current local commit: $CURRENT_COMMIT"
              
              # Fetch latest from origin
              echo "Fetching from origin..."
              if ! $GIT_PATH fetch origin main --force 2>&1; then
                echo "‚ö†Ô∏è Failed to fetch from origin. Proceeding with deploy..."
                CURRENT_COMMIT="fetch_failed"
              fi
              
              # Get remote commit from origin
              ORIGIN_COMMIT=$($GIT_PATH rev-parse origin/main 2>/dev/null || echo "none")
              echo "Remote commit (origin/main): $ORIGIN_COMMIT"
              
              # Check if upstream remote exists, if not add it
              if ! $GIT_PATH remote get-url upstream >/dev/null 2>&1; then
                echo "Upstream remote not found. Adding upstream remote..."
                $GIT_PATH remote add upstream https://github.com/enfyra/app.git 2>/dev/null || true
              fi
              
              # Fetch from upstream
              UPSTREAM_COMMIT="none"
              COMMITS_FROM_UPSTREAM=0
              if $GIT_PATH remote get-url upstream >/dev/null 2>&1; then
                echo "Fetching from upstream..."
                if $GIT_PATH fetch upstream main --force 2>&1; then
                  UPSTREAM_COMMIT=$($GIT_PATH rev-parse upstream/main 2>/dev/null || echo "none")
                  echo "Remote commit (upstream/main): $UPSTREAM_COMMIT"
                  
                  if [ "$CURRENT_COMMIT" != "none" ] && [ "$UPSTREAM_COMMIT" != "none" ]; then
                    COMMITS_FROM_UPSTREAM=$($GIT_PATH rev-list --count HEAD..upstream/main 2>/dev/null || echo "0")
                    echo "Commits available from upstream: $COMMITS_FROM_UPSTREAM"
                  fi
                else
                  echo "‚ö†Ô∏è Failed to fetch from upstream. Will check origin only."
                fi
              fi
              
              # Check commits from origin
              COMMITS_FROM_ORIGIN=0
              if [ "$CURRENT_COMMIT" != "none" ] && [ "$CURRENT_COMMIT" != "fetch_failed" ] && [ "$ORIGIN_COMMIT" != "none" ]; then
                COMMITS_FROM_ORIGIN=$($GIT_PATH rev-list --count HEAD..origin/main 2>/dev/null || echo "0")
                echo "Commits ahead from origin: $COMMITS_FROM_ORIGIN"
              fi
              
              # Decide whether to skip or deploy
              if [ "$CURRENT_COMMIT" = "none" ] || [ "$CURRENT_COMMIT" = "fetch_failed" ]; then
                echo "‚ö†Ô∏è Cannot determine current commit. Proceeding with deploy."
              elif [ "$COMMITS_FROM_ORIGIN" = "0" ] && [ "$COMMITS_FROM_UPSTREAM" = "0" ] && [ "$CURRENT_COMMIT" = "$ORIGIN_COMMIT" ]; then
                echo "‚úÖ No new commits detected."
                echo "   Current: $CURRENT_COMMIT"
                echo "   Origin:  $ORIGIN_COMMIT"
                echo "   Upstream: $UPSTREAM_COMMIT"
                echo "   Commits from origin: $COMMITS_FROM_ORIGIN"
                echo "   Commits from upstream: $COMMITS_FROM_UPSTREAM"
                echo "Skipping redeploy."
                exit 0
              else
                echo "üîÑ New commits detected!"
                echo "   Current: $CURRENT_COMMIT"
                echo "   Origin:  $ORIGIN_COMMIT"
                echo "   Upstream: $UPSTREAM_COMMIT"
                echo "   Commits from origin: $COMMITS_FROM_ORIGIN"
                echo "   Commits from upstream: $COMMITS_FROM_UPSTREAM"
                echo "Proceeding with deployment..."
              fi
            else
              echo "=== Deploy triggered by $EVENT_NAME - proceeding with deployment ==="
            fi

            # Sync with upstream and pull latest code
            echo "=== Syncing with upstream and updating code ==="
            
            # Ensure we're on main branch
            $GIT_PATH checkout main 2>/dev/null || true
            
            # Check if upstream remote exists, if not add it
            if ! $GIT_PATH remote get-url upstream >/dev/null 2>&1; then
              echo "Upstream remote not found. Adding upstream remote..."
              $GIT_PATH remote add upstream https://github.com/enfyra/app.git 2>/dev/null || {
                echo "‚ö†Ô∏è Failed to add upstream remote. Continuing without upstream sync..."
              }
            fi
            
            # Fetch from both origin and upstream
            echo "Fetching from origin and upstream..."
            $GIT_PATH fetch origin main --force
            if $GIT_PATH remote get-url upstream >/dev/null 2>&1; then
              $GIT_PATH fetch upstream main --force || {
                echo "‚ö†Ô∏è Failed to fetch from upstream. Continuing with origin only..."
              }
            fi
            
            # Save current state before reset
            CURRENT_BEFORE_RESET=$($GIT_PATH rev-parse HEAD 2>/dev/null || echo "none")
            echo "Current commit before reset: $CURRENT_BEFORE_RESET"
            
            # Reset to origin/main to get latest from our repo
            echo "Resetting to origin/main..."
            $GIT_PATH reset --hard origin/main
            $GIT_PATH clean -fd
            
            # Now merge upstream if available
            if $GIT_PATH remote get-url upstream >/dev/null 2>&1; then
              UPSTREAM_COMMIT=$($GIT_PATH rev-parse upstream/main 2>/dev/null || echo "none")
              CURRENT_COMMIT=$($GIT_PATH rev-parse HEAD 2>/dev/null || echo "none")
              
              if [ "$UPSTREAM_COMMIT" != "none" ] && [ "$CURRENT_COMMIT" != "none" ]; then
                # Check if upstream has commits we don't have
                COMMITS_BEHIND=$($GIT_PATH rev-list --count HEAD..upstream/main 2>/dev/null || echo "0")
                
                if [ "$COMMITS_BEHIND" != "0" ]; then
                  echo "üîÑ Found $COMMITS_BEHIND new commit(s) from upstream. Merging..."
                  
                  # Merge upstream/main into current branch (after reset to origin/main)
                  $GIT_PATH merge upstream/main --no-edit --no-ff || {
                    echo "‚ö†Ô∏è Merge conflict detected. Attempting to resolve with strategy..."
                    # If merge fails, abort and try with strategy
                    $GIT_PATH merge --abort 2>/dev/null || true
                    $GIT_PATH merge upstream/main --no-edit -X theirs || {
                      echo "‚ùå Failed to merge upstream. Keeping origin/main code."
                    }
                  }
                  
                  # Verify file exists after merge
                  if [ -f "app/plugins/03-app-settings.client.ts" ]; then
                    echo "‚úÖ File 03-app-settings.client.ts exists after merge"
                  else
                    echo "‚ö†Ô∏è File 03-app-settings.client.ts NOT found after merge"
                    echo "Checking upstream for the file..."
                    $GIT_PATH show upstream/main:app/plugins/03-app-settings.client.ts > /dev/null 2>&1 && {
                      echo "File exists in upstream. Attempting to restore..."
                      $GIT_PATH checkout upstream/main -- app/plugins/03-app-settings.client.ts 2>/dev/null || true
                    }
                  fi
                  
                  # Push merged code back to origin (if we have write access)
                  echo "Pushing merged code to origin..."
                  $GIT_PATH push origin main --force-with-lease 2>&1 || {
                    echo "‚ö†Ô∏è Failed to push to origin (may not have write access). Continuing with local merge..."
                  }
                else
                  echo "‚úÖ Already up to date with upstream."
                fi
              fi
            fi
            
            # Final verification
            FINAL_COMMIT=$($GIT_PATH rev-parse HEAD 2>/dev/null || echo "unknown")
            echo "‚úÖ Code updated to commit: $FINAL_COMMIT"
            
            # Verify critical files exist
            if [ -f "app/plugins/03-app-settings.client.ts" ]; then
              echo "‚úÖ Verified: app/plugins/03-app-settings.client.ts exists"
            else
              echo "‚ö†Ô∏è Warning: app/plugins/03-app-settings.client.ts NOT found"
              echo "Listing plugins directory:"
              ls -la app/plugins/ || true
            fi

            # Install dependencies with yarn
            echo "Installing dependencies with yarn..."
            $YARN_PATH install --frozen-lockfile

            # Ensure environment file exists (CI only verifies presence)
            if [ ! -f .env ]; then
              echo "‚ö†Ô∏è  .env not found. Please provision /apps/landing-app/.env manually on the server."
            fi

            # Build application
            echo "Building application..."
            $YARN_PATH build

            # Stop PM2 application completely to avoid conflicts
            echo "Stopping PM2 application..."
            $PM2_PATH stop $PROJECT_NAME || true
            $PM2_PATH delete $PROJECT_NAME || true

            # Clean start PM2 application
            echo "Starting PM2 application clean..."
            $PM2_PATH start ecosystem.config.cjs

            # Wait for app to initialize
            echo "Waiting for app initialization..."
            sleep 10

            # Show PM2 status
            $PM2_PATH status

            # Health check summary
            echo "=== Health Check ==="
            sleep 5
            if $PM2_PATH show $PROJECT_NAME | grep -q "online"; then
              echo "‚úÖ Application is running successfully"
            else
              echo "‚ùå Application failed to start"
              $PM2_PATH logs $PROJECT_NAME --lines 20 --nostream
              exit 1
            fi

            # Show logs without tailing (just print and exit)
            echo "=== Recent logs ==="
            $PM2_PATH logs $PROJECT_NAME --lines 30 --nostream || {
              echo "Using alternative log method..."
              timeout 3s $PM2_PATH logs $PROJECT_NAME --lines 30 || true
            }

            echo "=== PM2 Deployment completed successfully ==="
          ENDSSH

